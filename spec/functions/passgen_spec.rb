#!/usr/bin/env ruby -S rspec
# vim: set expandtab ts=2 sw=2:
require 'spec_helper'
require 'base64'
def parse_modular_crypt(input)
  retval = nil
  support_params = {
    'bcrypt' => {},
    'scrypt' => {},
    'argon2' => {},
  }
  algorithm_lookup = {
    '1' => 'md5',
    '2' => 'bcrypt',
    '3' => 'lmhash',
    '5' => 'sha256',
    '6' => 'sha512',
    'scrypt' => 'scrypt',
    'argon2' => 'argon2',
  }
  begin
    grab_params = false
    grab_salt = false
    grab_hash = false
    hash = {}
    split_input = input.split("$");
    index = 0;
    if (split_input.size > 2)
      split_input.each do |token|
        if (index == 1)
          hash['algorithm_code'] = token;
          if (algorithm_lookup.key?(token))
            hash['algorithm'] = algorithm_lookup[token];
            if (support_params.key?(hash['algorithm']))
              grab_params = true
            end
            grab_salt = true
            grab_hash = true
          end
        else
          if grab_params == true
            hash['params'] = token
            grab_params = false
          elsif grab_salt == true
            hash['salt'] = token
            grab_salt = false
          elsif grab_hash == true
            padding = token.length % 4
            hash['hash_orig'] = token
            hash['hash_base64'] = token.gsub(/\./, '+').rjust(padding + token.length, '=')
            hash['hash_decoded'] = Base64.decode64(hash['hash_base64']).bytes.to_a
            hash['hash_bitlength'] = hash['hash_decoded'].size * 8;
            grab_hash = false
          end
        end
        index += 1;
      end
      retval = hash
    end
  rescue Exception => e
    puts e
    retval = nil
  end
  return retval
end

def cases
  {
    "with no libkv specified" => {
    },
    "with libkv = false" => {
      "libkv" => false
    },
    "with libkv = true" => {
      "libkv" => true
    },
  }
end

describe 'passgen' do
      ## Legacy Options
      it 'should return the next to last created password if the second argument is "last"' do
        first_result = subject.call([ 'spectest'])
        second_result = subject.call([ 'spectest', {'length' => 33} ])
        expect(subject.call([ 'spectest', 'last' ])).to eql(first_result)
      end

      it 'should return a password of length 8 if the second argument is "8"' do
        result = subject.call([ 'spectest' ])
        expect(subject.call([ 'spectest', 8]).length).to eql(8)
      end
  cases.each do |description, settings|
    context description do
      let(:default_chars) do
        (("a".."z").to_a + ("A".."Z").to_a + ("0".."9").to_a).map do|x|
          x = Regexp.escape(x)
        end
      end
      let(:safe_special_chars) do
        ['@','%','-','_','+','=','~'].map do |x|
          x = Regexp.escape(x)
        end
      end

      let(:unsafe_special_chars) do
        (((' '..'/').to_a + ('['..'`').to_a + ('{'..'~').to_a)).map do |x|
          x = Regexp.escape(x)
        end - safe_special_chars
      end
      let(:base64_regex) do
        '^[a-zA-Z0-9+/=]+$'
      end
      # These tests check the actual password generated by passgen.
      # Ideally there should be two functions, one that generates a random password
      # and one that converts it into the modular crypt format, and passgen uses both.
      # But that's outside scope for now.

      it 'should run successfully with default arguments' do
        expect { run.with_params(['spectest', settings]) }.to_not raise_error
      end

      it 'should return a password that is 32 alphanumeric characters long by default' do
        result = subject.call(['spectest', settings])
        expect(result.length).to eql(32)
        expect(result).to match(/^(#{default_chars.join('|')})+$/)
      end

      it 'should work with a String length' do
        result = subject.call([ 'spectest', settings.merge({'length' => '32'}) ])
        expect(result.length).to eql(32)
        expect(result).to match(/^(#{default_chars.join('|')})+$/)
      end

      it 'should return a password that is 8 alphanumeric characters long if length is 8' do
        result = subject.call([ 'spectest', settings.merge({'length' => 8}) ])
        expect(result.length).to eql(8)
        expect(result).to match(/^(#{default_chars.join('|')})+$/)
      end

      it 'should return a password that contains "safe" special characters if complexity is 1' do
        result = subject.call([ 'spectest', settings.merge({'complexity' => 1}) ])
        expect(result.length).to eql(32)
        expect(result).to match(/(#{default_chars.join('|')})/)
        expect(result).to match(/(#{(safe_special_chars).join('|')})/)
        expect(result).not_to match(/(#{(unsafe_special_chars).join('|')})/)
      end
      it 'should return a password that only contains "safe" special characters if complexity is 1 and complex_only is true' do
        result = subject.call([ 'spectest', settings.merge({'complexity' => 1, 'complex_only' => true}) ])
        expect(result.length).to eql(32)
        expect(result).not_to match(/(#{default_chars.join('|')})/)
        expect(result).to match(/(#{(safe_special_chars).join('|')})/)
        expect(result).not_to match(/(#{(unsafe_special_chars).join('|')})/)
      end

      it 'should work with a String complexity' do
        result = subject.call([ 'spectest', settings.merge({'complexity' => '1'}) ])
        expect(result.length).to eql(32)
        expect(result).to match(/(#{default_chars.join('|')})/)
        expect(result).to match(/(#{(safe_special_chars).join('|')})/)
        expect(result).not_to match(/(#{(unsafe_special_chars).join('|')})/)
      end

      it 'should return a password that contains all special characters if complexity is 2' do
        result = subject.call([ 'spectest', settings.merge({'complexity' => 2}) ])
        expect(result.length).to eql(32)
        expect(result).to match(/(#{default_chars.join('|')})/)
        expect(result).to match(/(#{(unsafe_special_chars).join('|')})/)
      end
      it 'should return a password that only contains all special characters if complexity is 2 and complex_only is true' do
        result = subject.call([ 'spectest', settings.merge({'complexity' => 2, 'complex_only' => true}) ])
        expect(result.length).to eql(32)
        expect(result).to_not match(/(#{default_chars.join('|')})/)
        expect(result).to match(/(#{(unsafe_special_chars).join('|')})/)
      end
      if (settings["libkv"] != true)
      it 'should return the next to last created password if "last" is true' do
        first_result = subject.call([ 'spectest', settings.merge({'length' => 32}) ])
        second_result = subject.call([ 'spectest', settings.merge({'length' => 33}) ])
        third_result = subject.call([ 'spectest', settings.merge({'length' => 34}) ])
        expect(subject.call([ 'spectest', settings.merge({'last' => true}) ])).to eql(second_result)
      end
      it 'should return the current password if "last" is true but there is no previous password' do
        result = subject.call([ 'spectest', settings.merge({'length' => 32}) ])
        expect(subject.call([ 'spectest', settings.merge({'last' => true}) ])).to eql(result)
      end
      end
      # These tests check the resulting modular crypt formatted hash.
      {
        'md5' => {
          "code" => '1',
          "bits" => 128,
          "end_hash" => '$1$badsalt$lpOt58v4EmRjaID6kGO4j.'
        },
        'sha256' => {
          "code" => '5',
          "bits" => 256,
          "end_hash" => '$5$badsalt$FZYRq7gz.KjbTsd1uzm.lhPBvy9LAefLwvRn2PVVd37'
        },
        'sha512' => {
          "code" => '6',
          "bits" => 512,
          "end_hash" => '$6$badsalt$hk7dh/Mz.oPuPZgDkPrNU/WSQOOq6T8PA8FO4mmLkfGdgvyEvqd8HyD5UeD2aYysmczplpo5qkU8RYjX1R6LS0'
        }
      }.each do |hash_selection, object|
        context "when hash == #{hash_selection}" do

          let(:shared_options) do
            settings.merge({
              'hash' => hash_selection,
              'complexity' => 2
            })
          end
          let(:specific_options) do
            {
              'password' => 'reallybadpassword',
              'salt' => 'badsalt',
              'hash' => hash_selection,
            }
          end

          it 'should parse as modular crypt' do
            result = subject.call(['spectest', shared_options]);
            expect(parse_modular_crypt(result)).to_not eql(nil)
          end
          it "should use #{object['code']} as the algorithm code" do
            value = parse_modular_crypt(subject.call(['spectest', shared_options]));
            expect(value['algorithm_code']).to eql(object['code'])
          end
          it 'should contain a salt of complexity 0' do
            value = parse_modular_crypt(subject.call(['spectest', shared_options]));
            expect(value['salt']).to match(/^(#{default_chars.join('|')})+$/)
          end
          it 'should contain a base64 hash' do
            value = parse_modular_crypt(subject.call(['spectest', shared_options]));
            expect(value['hash_base64']).to match(/#{base64_regex}/)
          end
          it "should contain a valid #{hash_selection} hash after decoding" do
            result = subject.call(['spectest', shared_options]);
            value = parse_modular_crypt(result);
            expect(value['hash_bitlength']).to eql(object['bits'])
          end
          it "should return exactly #{object['end_hash']} when salt and password are specified" do
            result = subject.call(['spectest',specific_options])
            expect(result).to eql(object['end_hash'])
          end
        end
      end
    end
  end
end
